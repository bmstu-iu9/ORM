//Синтаксическое описание
S                    ::= (CreateTableStmt ';')+

CreateTableStmt      ::= CREATE TABLE (IF NOT EXISTS)?
                         QualifiedName '(' (TableElement (',' TableElement)*)? ')' Inherit?

QualifiedName        ::= ColId ('.'ColId)*

ColId                ::= IDENT //UNSUPPORTED TILL | UnreservedKeyword | ColNameKeyword

Inherit              ::= INHERITS '(' QualifiedName (',' QualifiedName)* ')'

TableElement         ::= ColumnDef | TableConstraint

ColumnDef            ::= ColId Typename ColConstraint*

Typename             ::= SimpleTypename ( '[' intConst? ']' )*    //intConst ни на что не влияет
                     |   SimpleTypename ARRAY ('[' intConst ']')?

SimpleTypename       ::= NumericType
                     |   CharacterType
                     |   DateTimeType
                     |   RECORD

NumericType          ::= INT
                     |   INTEGER
                     |   SMALLINT
                     |   BIGINT
                     |   REAL
                     |   FLOAT  ( '('intConst')' )? //1 <= intConst <= 53
                     |   DOUBLE PRECISION
                     |   DECIMAL
                     |   NUMERIC
                     |   BOOLEAN

CharacterType        ::= CharacterKeyword ( '(' intConst ')' )?

CharacterKeyword     ::= CHARACTER
                     |   CHAR
                     |   VARCHAR

DateTimeType         ::= TIMESTAMP ( '(' intConst ')' )? //0 <= intConst < 6
                     |   TIME ( '(' intConst ')' )?      //0 <= intConst < 6
                     |   DATE

TableConstraint      ::= CONSTRAINT ColId ConstraintElem
                     |   ConstraintElem

ConstraintElem       ::= UNIQUE      '(' ColId (',' ColId)* ')'
                     |   PRIMARY KEY '(' ColId (',' ColId)* ')'
                     |   FOREIGN KEY '(' ColId (',' ColId)* ')' REFERENCES QualifiedName
                         ('(' ColId (',' ColId)* ')' )? KeyActions?

ColConstraint        ::= CONSTRAINT ColId ColConstraintElem
                     |   ColConstraintElem

ColConstraintElem    ::= NOT NULL
                     |   NULL
                     |   UNIQUE
                     |   PRIMARY KEY
                     |   CHECK '(' BoolExpr ')'    //HERE NEED TO CHECK APPLICATION OF OPs
                     |   DEFAULT ExprNoVars        //ARITHMETIC, BOOL ONLY EXPR OR VALUE TILL
                     |   REFERENCES qualified_name ( '(' ColId (',' ColId)* ')' )? KeyActions?

KeyActions           ::= ON UPDATE KeyAction (ON DELETE KeyAction)?
                     |   ON DELETE KeyAction (ON UPDATE KeyAction)?

KeyAction            ::= NO ACTION
                     |   RESTRICT
                     |   CASCADE
                     |   SET NULL
                     |   SET DEFAULT

ExprNoVars           ::= ArithmExprNoVar | TRUE | FALSE | CharacterValue | DateValue

ArithmExprNoVar      ::= ArithmExprNoVarTerm ( {'+' | '-'} ArithmExprNoVarTerm )*
ArithmExprNoVarTerm  ::= ArithmExprNoVarFactor ( {'*' | '/'} ArithmExprNoVarFactor )*
ArithmExprNoVarFactor::= NumericValue
                     |   '-' ArithmExprNoVarFactor
                     |   '(' ArithmExprNoVar ')'

Expr                 ::= ArithmExpr | BoolExpr | TRUE | FALSE | CharacterValue | DateValue

BoolExpr             ::= BoolExprTerm (OR BoolExprTerm)*
BoolExprTerm         ::= BoolExprFactor (AND BoolExprFactor)*
BoolExprFactor       ::= BoolConst | NOT BoolExprFactor  | '(' BoolExpr ')'
BoolConst            ::= TRUE | FALSE | NULL | BoolStmt

BoolStmt             ::= ArithmExpr '<'  ArithmExpr
                     |   ArithmExpr '<=' ArithmExpr
                     |   ArithmExpr '>'  ArithmExpr
                     |   ArithmExpr '>=' ArithmExpr
                     |   ArithmExpr '='  ArithmExpr
                     |   ArithmExpr '!=' ArithmExpr
                     |   ArithmExpr IS NULL
                     |   ArithmExpr IS NOT NULL
                     |   ArithmExpr IS TRUE
                     |   ArithmExpr IS NOT TRUE
                     |   ArithmExpr IS FALSE
                     |   ArithmExpr IS NOT FALSE
                     |   ArithmExpr BETWEEN ArithmExpr AND ArithmExpr     // ARITHMETIC OR DATE ONLY TILL
                     |   ArithmExpr NOT BETWEEN ArithmExpr AND ArithmExpr // ARITHMETIC OR DATE ONLY TILL
                   //|   ColId LIKE StringValue                           // ONLY FOR STRING TYPE OF ColId
                   //|   ColId NOT LIKE StringValue                       // ONLY FOR STRING TYPE OF ColId
                   //|   StringValue LIKE ColId                           // ONLY FOR STRING TYPE OF ColId
                   //|   StringValue NOT LIKE ColId                       // ONLY FOR STRING TYPE OF ColId


ArithmExpr           ::= ArithmExprTerm ( {'+' | '-'} ArithmExprTerm )*
ArithmExprTerm       ::= ArithmExprFactor ( {'*' | '/'} ArithmExprFactor )*
ArithmExprFactor     ::= ColId //MUST BE NUMERIC TYPE
                     |   NumericValue
                     |   '-' ArithmExprFactor
                     |   '(' ArithmExpr ')'


ColNameKeyword::=
			  BETWEEN
			| BIGINT
			| BIT
			| BOOLEAN_P
			| CHAR_P
			| CHARACTER
			| COALESCE
			| DEC
			| DECIMAL_P
			| EXISTS
			| EXTRACT
			| FLOAT_P
			| GREATEST
			| GROUPING
			| INOUT
			| INT_P
			| INTEGER
			| INTERVAL
			| LEAST
			| NATIONAL
			| NCHAR
			| NONE
			| NULLIF
			| NUMERIC
			| OUT_P
			| OVERLAY
			| POSITION
			| PRECISION
			| REAL
			| ROW
			| SETOF
			| SMALLINT
			| SUBSTRING
			| TIME
			| TIMESTAMP
			| TREAT
			| TRIM
			| VALUES
			| VARCHAR
			| XMLATTRIBUTES
			| XMLCONCAT
			| XMLELEMENT
			| XMLEXISTS
			| XMLFOREST
			| XMLNAMESPACES
			| XMLPARSE
			| XMLPI
			| XMLROOT
			| XMLSERIALIZE
			| XMLTABLE

UnreservedKeyword::=
			  ABORT_P
			| ABSOLUTE_P
			| ACCESS
			| ACTION
			| ADD_P
			| ADMIN
			| AFTER
			| AGGREGATE
			| ALSO
			| ALTER
			| ALWAYS
			| ASSERTION
			| ASSIGNMENT
			| AT
			| ATTACH
			| ATTRIBUTE
			| BACKWARD
			| BEFORE
			| BEGIN_P
			| BY
			| CACHE
			| CALL
			| CALLED
			| CASCADE
			| CASCADED
			| CATALOG_P
			| CHAIN
			| CHARACTERISTICS
			| CHECKPOINT
			| CLASS
			| CLOSE
			| CLUSTER
			| COLUMNS
			| COMMENT
			| COMMENTS
			| COMMIT
			| COMMITTED
			| CONFIGURATION
			| CONFLICT
			| CONNECTION
			| CONSTRAINTS
			| CONTENT_P
			| CONTINUE_P
			| CONVERSION_P
			| COPY
			| COST
			| CSV
			| CUBE
			| CURRENT_P
			| CURSOR
			| CYCLE
			| DATA_P
			| DATABASE
			| DAY_P
			| DEALLOCATE
			| DECLARE
			| DEFAULTS
			| DEFERRED
			| DEFINER
			| DELETE_P
			| DELIMITER
			| DELIMITERS
			| DEPENDS
			| DETACH
			| DICTIONARY
			| DISABLE_P
			| DISCARD
			| DOCUMENT_P
			| DOMAIN_P
			| DOUBLE_P
			| DROP
			| EACH
			| ENABLE_P
			| ENCODING
			| ENCRYPTED
			| ENUM_P
			| ESCAPE
			| EVENT
			| EXCLUDE
			| EXCLUDING
			| EXCLUSIVE
			| EXECUTE
			| EXPLAIN
			| EXTENSION
			| EXTERNAL
			| FAMILY
			| FILTER
			| FIRST_P
			| FOLLOWING
			| FORCE
			| FORWARD
			| FUNCTION
			| FUNCTIONS
			| GENERATED
			| GLOBAL
			| GRANTED
			| GROUPS
			| HANDLER
			| HEADER_P
			| HOLD
			| HOUR_P
			| IDENTITY_P
			| IF_P
			| IMMEDIATE
			| IMMUTABLE
			| IMPLICIT_P
			| IMPORT_P
			| INCLUDE
			| INCLUDING
			| INCREMENT
			| INDEX
			| INDEXES
			| INHERIT
			| INHERITS
			| INLINE_P
			| INPUT_P
			| INSENSITIVE
			| INSERT
			| INSTEAD
			| INVOKER
			| ISOLATION
			| KEY
			| LABEL
			| LANGUAGE
			| LARGE_P
			| LAST_P
			| LEAKPROOF
			| LEVEL
			| LISTEN
			| LOAD
			| LOCAL
			| LOCATION
			| LOCK_P
			| LOCKED
			| LOGGED
			| MAPPING
			| MATCH
			| MATERIALIZED
			| MAXVALUE
			| METHOD
			| MINUTE_P
			| MINVALUE
			| MODE
			| MONTH_P
			| MOVE
			| NAME_P
			| NAMES
			| NEW
			| NEXT
			| NO
			| NOTHING
			| NOTIFY
			| NOWAIT
			| NULLS_P
			| OBJECT_P
			| OF
			| OFF
			| OIDS
			| OLD
			| OPERATOR
			| OPTION
			| OPTIONS
			| ORDINALITY
			| OTHERS
			| OVER
			| OVERRIDING
			| OWNED
			| OWNER
			| PARALLEL
			| PARSER
			| PARTIAL
			| PARTITION
			| PASSING
			| PASSWORD
			| PLANS
			| POLICY
			| PRECEDING
			| PREPARE
			| PREPARED
			| PRESERVE
			| PRIOR
			| PRIVILEGES
			| PROCEDURAL
			| PROCEDURE
			| PROCEDURES
			| PROGRAM
			| PUBLICATION
			| QUOTE
			| RANGE
			| READ
			| REASSIGN
			| RECHECK
			| RECURSIVE
			| REF
			| REFERENCING
			| REFRESH
			| REINDEX
			| RELATIVE_P
			| RELEASE
			| RENAME
			| REPEATABLE
			| REPLACE
			| REPLICA
			| RESET
			| RESTART
			| RESTRICT
			| RETURNS
			| REVOKE
			| ROLE
			| ROLLBACK
			| ROLLUP
			| ROUTINE
			| ROUTINES
			| ROWS
			| RULE
			| SAVEPOINT
			| SCHEMA
			| SCHEMAS
			| SCROLL
			| SEARCH
			| SECOND_P
			| SECURITY
			| SEQUENCE
			| SEQUENCES
			| SERIALIZABLE
			| SERVER
			| SESSION
			| SET
			| SETS
			| SHARE
			| SHOW
			| SIMPLE
			| SKIP
			| SNAPSHOT
			| SQL_P
			| STABLE
			| STANDALONE_P
			| START
			| STATEMENT
			| STATISTICS
			| STDIN
			| STDOUT
			| STORAGE
			| STRICT_P
			| STRIP_P
			| SUBSCRIPTION
			| SYSID
			| SYSTEM_P
			| TABLES
			| TABLESPACE
			| TEMP
			| TEMPLATE
			| TEMPORARY
			| TEXT_P
			| TIES
			| TRANSACTION
			| TRANSFORM
			| TRIGGER
			| TRUNCATE
			| TRUSTED
			| TYPE_P
			| TYPES_P
			| UNBOUNDED
			| UNCOMMITTED
			| UNENCRYPTED
			| UNKNOWN
			| UNLISTEN
			| UNLOGGED
			| UNTIL
			| UPDATE
			| VACUUM
			| VALID
			| VALIDATE
			| VALIDATOR
			| VALUE_P
			| VARYING
			| VERSION_P
			| VIEW
			| VIEWS
			| VOLATILE
			| WHITESPACE_P
			| WITHIN
			| WITHOUT
			| WORK
			| WRAPPER
			| WRITE
			| XML_P
			| YEAR_P
			| YES_P
			| ZONE

SelectStmt                  ::= simple_select
                            | select_with_parens

simple_clause               ::= SELECT ALL? target_list?
                                FROM from_list where_clause?
                                group_clause? having_clause?
                            |  SELECT distinct_clause target_list?
                               FROM from_list where_clause?
                               group_clause? having_clause?
                            |  select_clause UNION all_or_distinct? select_clause
                            |  select_clause INTERSECT all_or_distinct? select_clause
                            |  select_clause EXCEPT all_or_distinct? select_clause

select_with_parens          ::= '(' select_no_parens ')'
                            | '(' select_with_parens ')'

select_no_parens            ::= simple_select
                            | select_clause sort_clause

sort_clause                 ::= ORDER BY sortby_list

sortby_list                 ::= sortby (',' sortby)*

sortby                      ::= col_ref asc_desc?

col_ref                     ::= intConst //>=0 номер столбца
                            | ColId

asc_desc                    ::= ASC | DESC //ASC ON DEFAULT

target_list                 ::= target_el (',' target_el)*
target_el                   ::= target_expr AS IDENT
                            | target_expr IDENT
                            | target_expr
                            | '*'

target_expr                 ::= ColId                //если есть аггрегатные функции, то должен содержаться или в них или в GROUP BY
                            | AVG   '(' ColId ')'
                            | SUM   '(' ColId ')'
                            | COUNT '(' ColId ')'
                            | MIN   '(' ColId ')'
                            | MAX   '(' ColId ')'

from_list                   ::= table_ref (',' table_ref)*

where_clause                ::= WHERE bool_expr

group_clause                ::= GROUP BY col_ref (',' col_ref)*

having_clause               ::= HAVING bool_expr

distinct_clause             ::= DISTINCT (ON '(' expr_list ')')?

all_or_distinct             ::= ALL| DISTINCT

expr_list                   ::= col_ref (',' col_ref)*

table_ref                   ::= relation_expr alias_clause?
                            | select_with_parens alias_clause?
                            | joined_table alias_clause?

relation_expr               ::= qualified_name '*'?
                            | ONLY qualified_name
                            | ONLY '(' qualified_name ')'

alias_clause                ::= AS ColId
                            | ColId

joined_table                ::= '(' joined_table ')'
                            | table_ref CROSS JOIN table_ref
                            | table_ref join_type JOIN table_ref join_qual
                            | table_ref JOIN table_ref join_qual

join_type                   ::= FULL OUTER?
                            | LEFT OUTER?
                            | RIGHT OUTER?
                            | INNER

join_qual                   ::= USING '(' ColId (',' ColId)* ')'
                            | ON bool_expr


InsertStmt                  ::= INSERT INTO insert_target insert_rest

insert_target               ::= qualified_name (AS ColId)?

insert_rest                 ::= SelectStmt
                            | '(' insert_column_list ')' SelectStmt
                            | DEFAULT VALUES

insert_column_list          ::= qualified_name (',' qualified_name)

UpdateStmt                  ::= UPDATE relation_expr_opt_alias SET set_clause_list from_clause where_clause

set_clause_list             ::= set_clause (',' set_clause)*

//TODO сделать Expr
set_clause                  ::= set_target '=' Expr
                            | set_target '=' DEFAULT
                          //| set_target '=' SelectStmt              //UNSUPPORTED SelectStmt должен возвращать 1 строку
                            | '(' set_target_list ')' '=' Expr
                            | '(' set_target_list ')' '=' DEFAULT
                          //| '(' set_target_list ')' '=' SelectStmt //UNSUPPORTED SelectStmt должен возвращать 1 строку

set_target_list             ::= qualified_name (',' qualified_name)*

DeleteStmt                  ::= DELETE FROM relation_expr_opt_alias where_clause

relation_expr_opt_alias     ::= relation_expr
                            | relation_expr ColId
                            | relation_expr AS ColId

CreateFunctionStmt          ::= CREATE (OR REPLACE)? FUNCTION qualified_name func_args_with_defaults
                                RETURNS Typename createfunc_opt_list
                            | CREATE (OR REPLACE)? FUNCTION qualified_name func_args_with_defaults
                              RETURNS TABLE '(' table_func_column_list ')' createfunc_opt_list
                            | CREATE (OR REPLACE)? FUNCTION qualified_name '(' ')'
                              RETURNS TRIGGER createfunc_opt_list //В семантическом анализе, если имя NEW.smth валдировать это

CreateTriggerStmt           ::= CREATE TRIGGER qualified_name trig_time trig_action (OR trig_action)* ON qualified_name
                                FOR EACH ROW EXECUTE PROCEDURE qualified_name '(' ')' ';'

trig_time                   ::= BEFORE
                            | AFTER
                            | INSTEAD OF

trig_action                 ::= INSERT
                            | UPDATE
                            | DELETE

func_args_with_defaults     ::= '(' func_args_with_defaults_list? ')'

func_args_with_defaults_list::= func_arg_with_default (',' func_arg_with_default)*

func_arg_with_default       ::= func_arg
                            | func_arg DEFAULT a_expr
                            | func_arg '=' a_expr

func_arg                    ::= arg_class IDENT Typename
                            | IDENT arg_class Typename
                            | IDENT Typename
                            | arg_class Typename
                            | Typename

arg_class                   ::= IN
                            | OUT
                            | INOUT
                            | IN OUT

createfunc_opt_list         ::= AS '$$' func_as '$$' LANGUAGE plpgsql
                            | LANGUAGE plpgsql AS '$$' func_as '$$'

func_as                     ::= declare_block? BEGIN func_body* END ';'

declare_block               ::= DECLARE var_decl+

var_decl                    ::= qualified_name Typename (':=' ExprNoVars)? ';'

func_body                   ::= func_as
                            | var_assign
                            | return_stmt
                            | if_stmt
                            | loop_stmt
                            | NULL ';'
                            | raise_stmt
                            | InsertStmt ';'
                            | UpdateStmt ';'
                            | DeleteStmt ';'
                            | SelectStmt ';'

var_assign                  ::= qualified_name ':=' Expr ';'

raise_stmt                  ::= RAISE NOTICE string_const ';'
                            | RAISE EXCEPTION? string_const ';'

return_stmt                 ::= RETURN Expr ';'
                            | RETURN QUERY SelectStmt ';'

if_stmt                     ::= IF bool_expr THEN if_as (ELSIF bool_expr THEN if_as)? (ELSE if_as)? END IF ';'

if_as                       ::= declare_block? BEGIN func_body* END ';'
                            | declare_block? func_body? ';'

loop_stmt                   ::= (WHILE bool_expr)? LOOP cycle_as END LOOP ';'
                            | FOR IDENT IN REVERSE? arithm_expr '..' arithm_expr (BY arithm_expr)? LOOP cycle_as END LOOP ';'
                            | FOR loop_target IN SelectStmt cycle_as END LOOP ';'  //loop_target should be of type RECORD

cycle_as                    ::= declare_block? BEGIN cycle_body* END ';'
                            | declare_block? cycle_body? ';'

cycle_body                  ::= func_body
                            | EXIT (WHEN bool_expr)? ';'
                            | CONTINUE (WHEN bool_expr)? ';'

