//Синтаксическое описание
S                    ::= (CREATE CreateTableFunctionTrigger)*

CreateTableFunctionTrigger ::= (CreateTableStmt ';')
                           |   (CreateFunctionStmt ';')
                           //|   (CreateTriggerStmt ';')

CreateTableStmt      ::= TABLE (IF NOT EXISTS)?
                         QualifiedName '(' (TableElement (',' TableElement)*)? ')'

QualifiedName        ::= ColId ('.'ColId)*

ColId                ::= IDENT //UNSUPPORTED TILL | UnreservedKeyword | ColNameKeyword

TableElement         ::= ColumnDef | TableConstraint

ColumnDef            ::= ColId Typename ColConstraint*

Typename             ::= SimpleTypename ArrayType?

ArrayType            ::= ( '[' intConst? ']' )+    //intConst ни на что не влияет
                     |   ARRAY ('[' intConst ']')?

SimpleTypename       ::= NumericType
                     |   CharacterType
                     |   DateTimeType
                     |   RECORD
                     |   BOOLEAN

NumericType          ::= INT
                     |   INTEGER
                     |   SMALLINT
                     |   BIGINT
                     |   REAL
                     |   FLOAT  ( '('intConst')' )? //1 <= intConst <= 53
                     |   DOUBLE PRECISION
                     |   DECIMAL
                     |   NUMERIC

CharacterType        ::= CharacterKeyword ( '(' intConst ')' )?

CharacterKeyword     ::= CHARACTER
                     |   CHAR
                     |   VARCHAR

DateTimeType         ::= TIMESTAMP ( '(' intConst ')' )? //0 <= intConst < 6
                     |   TIME ( '(' intConst ')' )?      //0 <= intConst < 6
                     |   DATE

TableConstraint      ::= CONSTRAINT ColId ConstraintElem
                     |   ConstraintElem

ConstraintElem       ::= UNIQUE      '(' ColId (',' ColId)* ')'
                     |   PRIMARY KEY '(' ColId (',' ColId)* ')'
                     |   FOREIGN KEY '(' ColId (',' ColId)* ')' REFERENCES QualifiedName
                         ('(' ColId (',' ColId)* ')' )? KeyActions?

ColConstraint        ::= CONSTRAINT ColId ColConstraintElem
                     |   ColConstraintElem

ColConstraintElem    ::= NOT NULL
                     |   NULL
                     |   UNIQUE
                     |   PRIMARY KEY
                     |   CHECK '(' BoolExpr ')'    //HERE NEED TO CHECK APPLICATION OF OPs
                     |   DEFAULT ConstExpr         //ARITHMETIC, BOOL ONLY EXPR OR VALUE TILL
                     |   REFERENCES QualifiedName ( '(' ColId (',' ColId)* ')' )? KeyActions?

KeyActions           ::= ON UPDATE KeyAction (ON DELETE KeyAction)?
                     |   ON DELETE KeyAction (ON UPDATE KeyAction)?

KeyAction            ::= NO ACTION
                     |   RESTRICT
                     |   CASCADE
                     |   SET NULL
                     |   SET DEFAULT

Expr                 ::= ColExpr | CharacterValue | DateValue

ColExpr              ::= ColExprTerm ({'+' | '-' | OR} ColExprTerm)*
ColExprTerm          ::= ColExprFactor ({'*' | '/' | AND} ColExprFactor)*
ColExprFactor        ::= ColId             RHS?
                     |   '-' ColExprFactor ArithmRHS?
                     |   '(' ColExpr ')'   RHS?
                     |   NOT ColExprFactor BoolRHS?
                     |   NumericValue      ArithmRHS?
                     |   BoolConst         BoolRHS?
                     
ArithmExpr           ::= ArithmExprTerm ( {'+' | '-'} ArithmExprTerm )*
ArithmExprTerm       ::= ArithmExprFactor ( {'*' | '/'} ArithmExprFactor )*
ArithmExprFactor     ::= ColId //MUST BE NUMERIC TYPE
                     |   NumericValue
                     |   '-' ArithmExprFactor
                     |   '(' ArithmExpr ')'
                     
BoolExpr             ::= BoolExprTerm (OR BoolExprTerm)*
BoolExprTerm         ::= BoolExprFactor (AND BoolExprFactor)*
BoolExprFactor       ::= BoolConst BoolRHS? 
                     |   NOT BoolExprFactor BoolRHS? 
                     |   '(' BoolExpr ')' BoolRHS?
                     |   ColId RHS?                 //Check Type of Col here
                     |   ArithmConstExpr ArithmRHS

BoolConst            ::= TRUE | FALSE | NULL

//BoolStmt             ::= Expr RHS
                   //|   ColId LIKE StringValue                           // ONLY FOR STRING TYPE OF ColId
                   //|   ColId NOT LIKE StringValue                       // ONLY FOR STRING TYPE OF ColId
                   //|   StringValue LIKE ColId                           // ONLY FOR STRING TYPE OF ColId
                   //|   StringValue NOT LIKE ColId                       // ONLY FOR STRING TYPE OF ColId

RHS                 ::= ArithmRHS | BoolRHS

ArithmRHS           ::= '<'  ArithmExpr
                    |   '<=' ArithmExpr
                    |   '>'  ArithmExpr
                    |   '>=' ArithmExpr
                    |   '='  ArithmExpr
                    |   '!=' ArithmExpr
                    |   BETWEEN ArithmExpr AND ArithmExpr     // ARITHMETIC ONLY TILL

BoolRHS             ::= IS NOT? BoolConst

//TODO maybe make simple NumberValue instead of ArithmConstExpr
ConstExpr           ::= ArithmConstExpr | NOT? BoolConst | CharacterValue | DateValue | '(' ConstExpr ')'

ArithmConstExpr      ::= ArithmExprNoVarTerm ( {'+' | '-'} ArithmExprNoVarTerm )*
ArithmConstExprTerm  ::= ArithmExprNoVarFactor ( {'*' | '/'} ArithmExprNoVarFactor )*
ArithmConstExprFactor::= NumericValue
                     |   '-' ArithmExprNoVarFactor
                      
BoolConstExpr       ::= BoolConstExprTerm (OR BoolConstExprTerm)*
BoolConstExprTerm   ::= BoolConstExprFactor (AND BoolConstExprFactor)*
BoolConstExprFactor ::= BoolConst BoolRHS? 
                    | NOT BoolConstExprFactor BoolRHS?
                    | ArithmConstExpr ArithmConstRHS
                                      
ArithmConstRHS      ::= '<'  ArithmConstExpr
                    |   '<=' ArithmConstExpr
                    |   '>'  ArithmConstExpr
                    |   '>=' ArithmConstExpr
                    |   '='  ArithmConstExpr
                    |   '!=' ArithmConstExpr
                    |   BETWEEN ArithmConstExpr AND ArithmConstExpr     // ARITHMETIC ONLY TILL

CreateFunctionStmt          ::= (OR REPLACE)? FUNCTION QualifiedName '(' funcArgsWithDefaultsList? ')'
                                RETURNS Typename CreateFuncBody
                            |   (OR REPLACE)? FUNCTION QualifiedName '(' funcArgsWithDefaultsList? ')'
                                RETURNS TABLE '(' TableFuncColumnList ')' CreateFuncBody
                            |   (OR REPLACE)? FUNCTION QualifiedName '(' ')'
                                RETURNS CreateFunctionReturnStmt

CreateFunctionStmt          ::= (OR REPLACE)? FUNCTION QualifiedName '(' CreateFunctionRightPart

CreateFunctionRightPart     ::= ')' RETURNS CreateFunctionAllReturnStmt
                            |    funcArgsWithDefaultsList ')' RETURNS CreateFunctionNoTrReturnStmt

CreateFunctionAllReturnStmt ::= Typename CreateFuncBody
                            |   TABLE '(' TableFuncColumnList ')' CreateFuncBody
                            |   TRIGGER CreateFuncBody //В семантическом анализе, если имя NEW.smth валидировать это

CreateFunctionNoTrReturnStmt::= Typename CreateFuncBody
                            |   TABLE '(' TableFuncColumnList ')' CreateFuncBody

funcArgsWithDefaultsList    ::= funcArgWithDefault (',' funcArgWithDefault)*

funcArgWithDefault          ::= funcArg funcArgDefault?

funcArgDefault              ::= DEFAULT constExpr
                            |   '=' constExpr

funcArg                     ::= argClass IDENT? Typename
                            |   IDENT argClass? Typename
                            |   Typename

argClass                    ::= IN OUT?
                            |   OUT
                            |   INOUT

TableFuncColumnList         ::= IDENT Typename (',' IDENT Typename)*

CreateFuncBody              ::= AS '$$' funcAs '$$' LANGUAGE plpgsql
                            |   LANGUAGE plpgsql AS '$$' funcAs '$$'

funcAs                      ::= declareBlock? BEGIN funcBody* END ';'

declareBlock                ::= DECLARE variableDecl+

variableDecl                ::= QualifiedName Typename (':=' ConstExpr)? ';'

funcBody                    ::= funcAs
                            |   variableAssign
                            |   returnStmt
                            |   ifStmt
                            |   loopStmt
                            |   NULL ';'
                            |   raiseStmt
                            |   InsertStmt ';'
                            |   UpdateStmt ';'
                            |   DeleteStmt ';'
                            |   SelectStmt ';'

variableAssign              ::= QualifiedName ':=' Expr ';'

raiseStmt                   ::= RAISE raiseLevel CharacterValue ';'

raiseLevel                  ::= NOTICE
                            |   EXCEPTION?

returnStmt                  ::= RETURN returnedValue ';'

returnedValue               ::= Expr
                            |   QUERY SelectStmt

ifStmt                      ::= IF boolExpr THEN ifBody (ELSIF boolExpr THEN ifBody)? (ELSE ifBody)? END IF ';'

ifBody                      ::= funcAs
                            |   (funcBody)?

loopStmt                    ::= (WHILE boolExpr)? LOOP cycleDecl END LOOP ';'
                            |   FOR IDENT IN forClause

forClause                   ::= REVERSE? arithmExpr '..' arithmExpr (BY arithmExpr)? LOOP cycleDecl END LOOP ';'
                            |   SelectStmt cycleDecl END LOOP ';'  //ident should be of type RECORD

cycleDecl                   ::= declareBlock? BEGIN cycleBody* END ';'
                            |   cycleBody*

cycleBody                   ::= variableAssign
                            |   returnStmt
                            |   ifCycleStmt
                            |   loopStmt
                            |   NULL ';'
                            |   raiseStmt
                            |   InsertStmt ';'
                            |   UpdateStmt ';'
                            |   DeleteStmt ';'
                            |   SelectStmt ';'
                            |   EXIT (WHEN boolExpr)? ';'
                            |   CONTINUE (WHEN boolExpr)? ';'

ifCycleStmt                 ::= IF boolExpr THEN ifCycleBody (ELSIF boolExpr THEN ifCycleBody)? (ELSE ifCycleBody)? END IF ';'

ifCycleBody                 ::= declareBlock? BEGIN cycleBody* END ';'
                            |   (cycleBody)?

//SelectStmt                  ::= simpleSelectClause
//                            |   selectWithParens

SelectStmt                  ::= SELECT allDistinctClause? targetList?
                                FROM fromList whereClause?
                                groupClause? havingClause? sortClause?
                                ( unionIntOps allOrDistinct? SelectStmt )?
//                            |   SelectStmt UNION allOrDistinct? SelectStmt
//                            |   SelectStmt INTERSECT allOrDistinct? SelectStmt
//                            |   SelectStmt EXCEPT allOrDistinct? SelectStmt

allDistinctClause           ::= ALL
                            |   DISTINCT (ON '(' colRefList ')')?

allOrDistinct               ::= ALL | DISTINCT

unionIntOps                 ::= UNION
                            |   INTERSECT
                            |   EXCEPT

//selectWithParens            ::= '(' selectNoParens ')'
//                            |   '(' selectWithParens ')'

//selectNoParens              ::= simpleSelectClause
//                            |   SelectStmt sortClause

sortClause                  ::= ORDER BY sortByElem (',' sortByElem)*

sortByElem                  ::= colRef ascDesc?

colRef                      ::= intConst //>=0 номер столбца
                            |   ColId

ascDesc                     ::= ASC | DESC //ASC ON DEFAULT

targetList                  ::= targetEl (',' targetEl)*

targetEl                    ::= targetExpr aliasClause?
                            |   '*'

targetExpr                  ::= ColId                //если есть аггрегатные функции, то должен содержаться или в них или в GROUP BY
                            |   AVG   '(' ColId ')'
                            |   SUM   '(' ColId ')'
                            |   COUNT '(' ColId ')'
                            |   MIN   '(' ColId ')'
                            |   MAX   '(' ColId ')'

fromList                    ::= tableRef (',' tableRef)*

whereClause                 ::= WHERE boolExpr

groupClause                 ::= GROUP BY colRef (',' colRef)*

havingClause                ::= HAVING boolExpr

colRefList                  ::= colRef (',' colRef)*

tableRef                    ::= QualifiedName aliasClause? ( joinType? JOIN tableRef joinQual )?

aliasClause                 ::= AS ColId
                            |   ColId

joinType                    ::= FULL OUTER?
                            |   LEFT OUTER?
                            |   RIGHT OUTER?
                            |   INNER

joinQual                    ::= USING '(' ColId (',' ColId)* ')'
                            |   ON boolExpr


InsertStmt                  ::= INSERT INTO insertTarget insertRest

insertTarget                ::= QualifiedName (AS ColId)?

insertRest                  ::= SelectStmt
                            |   '(' insertColumnList ')' InsertSelectOrValues
                            |   DEFAULT VALUES

InsertSelectOrValues        ::= SelectStmt
                            |   VALUES '(' insertedValue (',' insertedValue)* ')'

insertedValue               ::= DEFAULT
                            |   Expr

insertColumnList            ::= ColId (',' ColId)*

UpdateStmt                  ::= UPDATE qualifiedName aliasClause?
                                SET setClauseList (FROM fromList)? whereClause?

setClauseList               ::= setClause (',' setClause)*


setClause                   ::= QualifiedName '=' setClauseRest
                            |   '(' setTargetList ')' '=' setClauseRest

setClauseRest               ::= Expr
                            |   DEFAULT
                            |   SelectStmt  //UNSUPPORTED SelectStmt должен возвращать 1 строку (try_catch)

setTargetList              ::= QualifiedName (',' QualifiedName)*

DeleteStmt                  ::= DELETE FROM qualifiedName aliasClause? whereClause?

//CreateTriggerStmt           ::= TRIGGER QualifiedName trigTime trigAction (OR trigAction)* ON QualifiedName
//                                FOR EACH ROW (WHEN '(' boolExpr ')')? EXECUTE PROCEDURE QualifiedName '(' ')' ';' //instead of not supports when clause
//
//trigTime                    ::= BEFORE
//                            |   AFTER
//                            |   INSTEAD OF
//
//trigAction                  ::= INSERT
//                            |   UPDATE (OF ColId (',' ColId)* )?
//                            |   DELETE

